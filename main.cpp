#include <iostream>
#include "heap.hpp"

void debug_heap() {
    Chunk* curr = globalBase;
    std::cout << "--- HEAP STATE ---" << std::endl;
    if (!curr) std::cout << "Heap is empty (nullptr)" << std::endl;
    while (curr) {
        std::cout << "[Addr: " << curr 
                  << " | Size: " << curr->size 
                  << " | Free: " << (curr->isFree ? "YES" : "NO") 
                  << " | Next: " << curr->next << "]" << std::endl;
        curr = curr->next;
    }
    std::cout << "------------------" << std::endl;
}

/*
 * This main logic was generated by AI 
 * this project is hard enough for me, ive generated this 
 * so i can focus on the real learning i.e buiding my own memory manager 
 */
int main()
{
    std::cout << "Testing myAllocator with Realloc..." << std::endl;

    // --- TEST 1: Basic Allocation ---
    void* p1 = my_alloc(100);
    void* p2 = my_alloc(100);
    std::cout << "\nInitial allocation (p1 and p2):" << std::endl;
    debug_heap();

    // --- TEST 2: Realloc Shrink (Decreasing Size) ---
    // Should split the block and create a new free chunk
    std::cout << "\nTest 2: Shrinking p1 from 100 to 40 bytes..." << std::endl;
    void* p1_new = my_realloc(p1, 40);
    if (p1 == p1_new) std::cout << "SUCCESS: Address remained the same (In-place)." << std::endl;
    debug_heap();

    // --- TEST 3: Realloc Expansion In-place ---
    // We just freed space after p1 due to shrinking. Let's expand back.
    std::cout << "\nTest 3: Expanding p1 back to 80 bytes (In-place expected)..." << std::endl;
    p1 = my_realloc(p1_new, 80);
    debug_heap();

    // --- TEST 4: Realloc Move (No space in front) ---
    // p2 is occupying the space after p1. If we ask for 500 bytes, p1 must move.
    std::cout << "\nTest 4: Expanding p1 to 500 bytes (Move expected because p2 is in the way)..." << std::endl;
    void* p1_moved = my_realloc(p1, 500);
    if (p1 != p1_moved) std::cout << "SUCCESS: Block moved to a new address." << std::endl;
    debug_heap();

    // --- TEST 5: Cleaning up ---
    std::cout << "\nTest 5: Freeing everything..." << std::endl;
    my_free(p1_moved);
    my_free(p2);
    debug_heap();

    // --- TEST 6: Calloc (Zero Initialization) ---
    std::cout << "\nTest 6: Testing my_calloc (10 integers, should be all zeros)..." << std::endl;
    
    // Alocando 10 inteiros
    size_t num_elements = 10;
    int* p_calloc = (int*)my_calloc(num_elements, sizeof(int));
    
    if (p_calloc) {
        bool is_zeroed = true;
        std::cout << "Values: [ ";
        for (size_t i = 0; i < num_elements; i++) {
            std::cout << p_calloc[i] << " ";
            if (p_calloc[i] != 0) is_zeroed = false;
        }
        std::cout << "]" << std::endl;

        if (is_zeroed) {
            std::cout << "SUCCESS: All memory initialized to zero." << std::endl;
        } else {
            std::cout << "FAILURE: Memory contains garbage/junk values." << std::endl;
        }
    }
    
    debug_heap();
    my_free(p_calloc);
    
    // --- TEST 7: Calloc Overflow Prevention ---
    std::cout << "\nTest 7: Testing my_calloc overflow protection..." << std::endl;
    // calloc(ing) a value close to size_t limit
    void* p_overflow = my_calloc((size_t)-1 / 2, 4); 
    
    if (p_overflow == nullptr) {
        std::cout << "SUCCESS: Overflow detected and allocation prevented." << std::endl;
    } else {
        std::cout << "FAILURE: Allocator did not catch the overflow!" << std::endl;
        my_free(p_overflow);
    }
}
